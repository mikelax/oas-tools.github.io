{"/blog/articles/announcingv3":{"title":"OAS Tools v3 is out!","data":{"":"After a period of inactivity without major releases, OAS Tools v3 is finally out. The project has been resumed after being discontinued for more than a year.You may find that the project has suffered many changes, including the creation of a GitHub organization where the repositories created by the team are found. This change comes mainly due to the huge refactorization task that has been done within the core library of the system.The old OAS Tools library has been splitted in multiple packages, including a command line interface tool and a commons library. The core package contains the main functionality that helps implementing OpenAPI 3.X features, whereas the Commons Library and the CLI helps creating new modules and services.","extensible-through-external-modules#Extensible through external modules":"The Commons library provides useful functionality that has helped developing the OAS Tools core library itself, and also helps developing new modules that can extend OAS Tools functionality.\nflowchart LR;\nCore(OAS Tools \\n Core) -----> ExtModule(External \\n Modules)\nExtModule -----> Commons(Commons \\n Library)\nCore -----> Commons\nThose new packages are integrated inside the execution flow, opening up the range of possibilities when initializing a server based on the OpenAPI specification. Thanks to this feature, it is possible to create validators for new standards, complex authentication modules or even telemetry packages.Although it may seem hard to develop a complete new module for OAS Tools, it turns out to be a really easy task. Thanks to the new command line interface that is capable of generate the code scaffolding for creating any type of module!","interactive-command-line-tool#Interactive Command Line Tool":"The new command line tool relies on the inquirer library to provide easy and interactive menus that guide you through the creation of many resources.\n? Select a resource to initialize (Use arrow keys)\nServer\nModule\nDevelopment environment\n> OpenAPI File\nYou prefer inserting commands the traditional way? Don't worry, OAS Tools CLI allows using commands with many options that lets you configure your project in many ways! Just have a look at the CLI documentation.","openapi-31-support#OpenAPI 3.1 support":"After some time OAS Tools is finally 100% compatible with OpenAPI 3.1, the latest OpenAPI version. Giving support to this new version of the OpenAPI specification has been a complicated achievement, but thanks to the AJV the new JSON Schema draft 2020-12 can be validated and so does the OpenAPI 3.1 declaration.Update your OpenAPI declaration and discover the new OAS Tools framework by setting a simple line to your OpenAPI document!\nopenapi: 3.1.0\ninfo:\n...","and-more#And more...":"After many months of development, the new OAS Tools has been released, but there's definetly more to come! Stay tuned by activating notification for our Discussion and check this new version docs! ."}},"/docs/cli":{"title":"CLI","data":{"":"In order to run the command line interface tool, you can install it with npm:\nnpm install -g @oas-tools/cli\nThen you can run any commands through oas-tools <command>. Besides, it is also possible to run OAS Tools CLI command with npx:\nnpx @oas-tools/cli <command>\n\nThe following sections describe the different commands available through the CLI tool, you can always check them out by running oas-tools --help.","init#Init":"The init command is used for initializing a resource. The available resources to initialize are described in the following sections, you can configure each of them after running:\noas-tools init\nAn interactive menu will prompt, where you can choose a resource to initialize and configure it easily by answering some questions. However, the interactive prompt is not compatible with every terminal, taht's why it is possible to run each command the traditional way, as the following sections describe.","server#Server":"A REST service can be initialized through the command line tool by running the following command:\noas-tools init server <OpenAPI v3 file in YAML or JSON> [options]\nThe possible options are listed in the table below:\nOption\tDefault\tDescription\t-n, --path-name <dirpath>\tgenerated-server\tPath for the generated directory\t-p, --port <port>\t8080\tPort to which the server will be listening\t-r, --recursive\t-\tGenerate path-name directories recursively\t-d, --dereference\t-\tDereference the OpenAPI document\t-m, --esm\t-\tUse ESM syntax instead of CommonJS\t-j, --json\t-\tGenerate oas-doc file as JSON instead of YAML\t-c, --container\t-\tGenerate required files to build Docker image\t-z, --zip\t-\tGenerate a zip and delete the folder\t-h, --help\t-\tDisplay help for command","module#Module":"A Module can be initialized through the command line tool by running the following command:\noas-tools init module <Module name> [options]\nThe possible options are listed in the table below:\nOption\tDefault\tDescription\t--generate-server\t-\tGenerate a test server for the new module\t-m, --esm\t-\tUse ESM syntax instead of CommonJS\t-h --help\t-\tDisplay help for command\n\nBear in mind that using ESM syntax will set the type: module in the generated package.json. You may need to use a transpiler like Babel.js or move to Typescript in order for the new module to be usable on CommonJS servers.","development-environment#Development environment":"A complete development workspace can be initialized through the command line tool by running the following command:\noas-tools init dev-env [options]\nThe possible options are listed in the table below:\nOption\tDefault\tDescription\t-g, --git-repo <url>\thttps://github.com/oas-tools/oas-tools.git\tClone OAS Tools from a repository\t-b,  --git-branch <name>\tdevelop\tBranch to clone the repo from\t--clone-commons\t-\tClone the commons library\t-h --help\t-\tDisplay help for command","openapi-file#OpenAPI File":"This command is not recommended to use in the traditional way when provided a file with too many resources declared. Instead switch to a terminal which have interactive support and run oas-tools init or create the OpenAPI declaration manually.\nThis command lets you generate a valid OpenAPI file from an entity resource:\noas-tools init file <Resource file> -n <names> -i <ids> -o <operations> [options]\n\nOption\tRequired\tDefault\tDescription\t-n, --resource-name <name...>\ttrue\t-\tList containing each resource name\t-i,  --id-property <ids...>\ttrue\t-\tList containing each resource id property\t-o, --operations\ttrue\t-\tObject containing available operations for each resource. the object format is: name=op1,op2,op3...\t-v, --version <version>\tfalse\t3.0.3\tThe OpenAPI version that will be used\t-t, --title <title>\tfalse\tAutogenerated Api\tTitle for the described API\t-d, --description <text>\tfalse\tGenerated with OAS Tools CLI\tDescription for the described API\t-p, --path-name <path>\tfalse\tprocess.cwd()/oas-doc.[json|yaml]\tPath where the file will be generated\t-j, --json\t-\tGenerate oas-doc file as JSON instead of YAML\t-h --help\t-\tDisplay help for command\nFor example, given the following resource declaration:\n// resources.json\n[\n{\n\"userId\": 1,\n\"name\": \"User\",\n\"email\": \"user@example.com\"\n},\n{\n\"petId\": 1,\n\"petName\": \"Garfield\",\n\"type\": \"Cat\"\n}\n]\nA valid OpenAPI declaration could be generated running the following command:\noas-tools init file ./resources.json -n User Pet -i userId petId -o User=GET,POST,PUT Pet=GET\nThe command above will generate an OpenAPI declaration in which the resource User has three operations: GET, POST and PUT, whereas the resource PET has only a GET operation.","validate#Validate":"The validate command is a simple instruction that takes no options. Its only purpose is to validate an OpenAPI document in the same way that OAS Tools core library does. It will output validation errors formatted as explained in the Validation section.\noas-tools validate <path to OpenApi file>"}},"/docs/compatibility":{"title":"Compatibility","data":{"":"The following table shows the compatibility relationship between the different packages integrated within the OAS Tools ecosystem and different technologies and standards:\n\n\n\nCOMPATIBILITY CHART\n\nNode.js Version\n\nOpenAPI version\n\nJavascript syntax\n\n\n\n\n\nPackage\n\n<=v12\n\nv14\n\nv16\n\nv18\n\n3.0\n\n3.1\n\nCommonJS\n\nESM\n\n\n\n@oas-tools/cli\n\n✘\n\n✓\n\n✓\n\n✓\n\n✓\n\n✓\n\n-\n\n-\n\n\n\n@oas-tools/commons\n\n✘\n\n✓\n\n✓\n\n✓\n\n✓\n\n✓\n\n✓\n\n✓\n\n\n\noas-tools (v2)\n\nSecurity\n\n✓\n\n✓\n\n✓\n\n?\n\n✓\n\n✘\n\n✓\n\n✘\n\n\n\nAuth\n\n✓\n\n✓\n\n✓\n\n?\n\n✓\n\n✘\n\n✓\n\n✘\n\n\n\nValidator\n\n✓\n\n✓\n\n✓\n\n?\n\n✓\n\n✘\n\n✓\n\n✘\n\n\n\nRouter\n\n✓\n\n✓\n\n✓\n\n?\n\n✓\n\n✘\n\n✓\n\n✘\n\n\n\nSwaggerUI\n\n✓\n\n✓\n\n✓\n\n?\n\n✓\n\n✘\n\n✓\n\n✘\n\n\n\n@oas-tools/core (v3)\n\nParams\n\n✘\n\n✓\n\n✓\n\n✓\n\n✓\n\n✓\n\n✓\n\n✓\n\n\n\nSecurity\n\n✘\n\n✘\n\n✓\n\n✓\n\n✓\n\n✓\n\n✓\n\n✓\n\n\n\nValidator\n\n✘\n\n✓\n\n✓\n\n✓\n\n✓\n\n✓\n\n✓\n\n✓\n\n\n\nRouter\n\n✘\n\n✓\n\n✓\n\n✓\n\n✓\n\n✓\n\n✓\n\n✓\n\n\n\nSwaggerUI\n\n✘\n\n✓\n\n✓\n\n✓\n\n✓\n\n✘\n\n✓\n\n✓"}},"/docs/migration":{"title":"Migration Guide","data":{"":"OAS Tools npm package has been renamed from oas-tools to @oas-tools/core. When updating the package take into account that you have to first remove the old package through npm remove oas-tools, install the new with npm install --save @oas-tools/core and modify the imports.","updating-from-oas-tools-v2#Updating from OAS Tools v2":"OAS Tools v3 is backwards compatible with the v2, so no changes need to be made to the code. However, if you want to use exclusive features from the v3, you need to change your code to match the OAS Tools v3 configuration and initialization.","configuration#Configuration":"Since OAS Tools is backward compatible, the old v2 options are parsed to newer options upon initialization, and for those options that have been moved to external middlewares, the modules are automatically integrated in OAS Tools (but you still need to install them through NPM). The following table relates the configuration options of OAS Tools v2 to those of the new v3:\nV2 Option\ttype\tV3 Option\ttype\tloglevel\tString\tlogger.level\tString\tlogfile\tString\tlogger.logFile && logger.logFilePath\tBoolean && String\tcustomLogger\tObject\tlogger.customLogger\tObject\tcustomErrorHandling\tBoolean\tmiddleware.error.disable && middleware.error.customHandler\tFunction\tcontrollers\tString\tmiddleware.router.controllers\tString\tcheckControllers\tBoolean\t* V3 Controllers are always checked for existence\t-\tstrict\tBoolean\tmiddleware.validator.strict\tBoolean\trouter\tBoolean\tmiddleware.router.disable\tBoolean\tvalidator\tBoolean\tmiddleware.router.requestValidation middleware.router.responseValidation\tBoolean\toasSecurity\tBoolean\tmiddleware.security.disable\tBoolean\tsecurityFile\tObject\tmiddleware.security.auth\tObject\toasAuth\tBoolean\t* Implemented by OAS Auth\t-\tgrantsFile\tObject\t* Implented by OAS Auth\t-\tdocs.apiDocs\tString\t* OAS Doc is not exposed in endpoints\t-\tdocs.apiDocsPrefix\tString\t* OAS Doc is not exposed in endpoints\t-\tdocs.swaggerUi\tString\tmiddleware.swagger.path\tString\tdocs.swaggerUiPrefix\tString\tMust be included in middleware.swagger.path\t-\t-\t-\tpackageJSON\tString\t-\t-\toasFile\tString\t-\t-\tuseAnnotations\tString\t-\t-\tmiddleware.swagger.disable\tBoolean\t-\t-\tmiddleware.swagger.ui\tObject\t-\t-\tmiddleware.error.printStackTrace\tBoolean","initialization#Initialization":"The intitialization function has been modified in the v3 to return a Promise instead of taking a callback in its arguments. However, the older initialization method is still possible and will get the v2 options parsed to v3. The new OAS Tools v3 initialization takes two arguments: express app, and optionally the configuration object. Check out the Configuration section for more information.\nconst http = require('http');\nconst express = require(\"express\");\nconst oasTools = require(\"@oas-tools/core\");\nconst app = express();\n\napp.use(express.json());\nconst serverPort = 8080;\n\noasTools.initialize(app).then(() => {\nhttp.createServer(app).listen(serverPort, () => console.log(\"Server started!\"));\n})\n\nThe above snippet is using CommonJS syntax, but OAS Tools v3 is fully compatible with ESM/import syntax."}},"/docs/customization/custom-loger":{"title":"Adding a custom logger","data":{"":"OAS Tools provide a built-in logger that relies on a winston logger under the hood. This built-in Logger class is built by composition, meaning the underlying winston instance can be overriden.","creating-a-custom-logger#Creating a custom Logger":"As mentioned above, the custom logger must be a winston instance. The example below will show how to create a simple logger with this library, but moore complex designs can be achieved, check out the winston documentation.Having winston been installed through npm install --save winston, you can create a simple logger using the createLogger function:\n// logger.js\n\nconst winston = require('winston');\n\nmodule.exports = winston.createLogger({\nlevel: 'info',\nformat: winston.format.json(),\ndefaultMeta: { service: 'user-service' },\ntransports: [\nnew winston.transports.Console({\nformat: winston.format.simple(),\n})\n]\n});","integrating-the-logger#Integrating the Logger":"To integrate the new logger inside your OAS Tools service, just import your class under logger.customLogger property inside the configuration file:\n// oastools.config.js\n\nconst logger = require('./logger');\n\nmodule.exports = {\nlogger: {\ncustomLogger: logger\n}\n}\n\nBear in mind that setting a customLogger will cause the rest of logging options to be ignored."}},"/docs/customization/external-modules":{"title":"External modules","data":{"":"One of the major new features coming out with this version 3.0 is the possibility to integrate third-party middleware classes and functions into the OAS Tools middleware chain. The OAS Tools' team has already developed a couple of modules that add useful functionalities to the system:\nOAS Auth: An authentication module that provides security handlers and middleware to validate and assign role-based permission levels based on JSON Web Token.\nSLA Rate Limit: A Module capable of reading SLA4OAI specification and limit the requests to the service based on what has been specified in a service-level agreement (SLA).","installing-modules#Installing modules":"External middleware can be installed through the use() function provided by the OAS Tools core library. The use() function takes three arguments:\nMiddleware (Required): The imported middleware class or function that is being integrated into the chain.\nConfiguration (optional): An object containing the configuration for the middleware that is being integrated.\nPriotity (optional): The position of the middleware chain in which it will be inserted. By default external modules are inserted in the third position, right after the request validation middleware.\n\n\nflowchart LR;\nOAS-PARAMS(0 - Parameter \\n Parser)\nOAS-SECURITY(1 - Security \\nMiddleware)\nOAS-RQVALIDATOR(2 - Request \\n Validation)\nOAS-RPVALIDATOR(4 - Response \\n Validation)\nOAS-ROUTER(5 - Router \\n Middleware)\nEXTERNAL(3 - External \\n Middleware)\nOAS-PARAMS-->OAS-SECURITY\nOAS-SECURITY-->OAS-RQVALIDATOR\nOAS-RQVALIDATOR-.-EXTERNAL\nEXTERNAL-.-OAS-RPVALIDATOR\nOAS-RPVALIDATOR-->OAS-ROUTER\nstyle EXTERNAL stroke-dasharray: 5 5,stroke-width:2px\n\nTake into account that if two middleware are being inserted at the same position, they will be inserted in the same order in which the use() function is called. That means if two middleware are being inserted at position 0, the first one will end up in position 1 and the second one in position 0.\nThe following example shows how the OAS Auth middleware is integrated. It is being registered in the second position of the middleware chain.\nimport { OASBearerJWT } from 'oas-auth/middleware';\n\nconst authCfg= {acl: { secSchemeName:'route/to/permissions.json' }}\n\noasTools.use(OASBearerJWT, authCfg, 2);\noasTools.initialize(app).then(() => ...)","developing-modules#Developing modules":"Creating new OAS Tools' compatible middleware is as easy as declaring a function or a clase and start using it. That is because the use() function accepts middleware functions directly, as well as wrapping classes. The following two sections describe this casuistry.","basic-modules#Basic modules":"In case you want to create a basic middleware for OAS Tools, there is no need to declare a new class. OAS Tools directly accepts function types in the use function. This is perfect when your function doesn't require configuration or a previous initialization operation:\nfunction myCustomMiddleware (req, res, next) {\n/* Do something */\n\nnext();\n}\n\noasTools.use(myCustomMiddleware)\n\nIt is a good practise to declare a function with its name instead of directly declare an unnamed function inside use(). This is because the server will log the registered middlewares, and therefore, if your function is unnamed it will print 'undefined'.","complex-modules#Complex modules":"In case your module requires additional configuration, an initialization process or a complex registration, you will need to declare a class. To make that task easier, the Commons library provides a class, OASBase,  which already has the definition for basic functions like registering the middleware.When declaring your middleware as a class, you will need to extend OASBase and declare a static function initialize that receives the module configuration and the OpenAPI document in its arguments, and returns an instance of the class.\nYou can easily initialize a new module through the command line interface by running oas-tools init module. Check out the CLI section\n\nconst { OASBase } = require(\"@oas-tools/commons\");\n\nmodule.exports.MyMiddleware extends OASBase {\n\nconstructor(oasFile, middleware) {\nsuper(oasFile, middleware); // Call parent constructor\n}\n\nstatic initialize(oasFile, config) {\n/* The code here will run during OAS Tools initialization */\n\nreturn new MyMiddleware(oasFile, (req, res, next) => {\n/* The code here will run for every request */\n\nnext();\n})\n}\n}\n\nIn case you need to perform a more complex registration, you may override the register() function, like shown below:\nconst { OASBase } = require(\"@oas-tools/commons\");\n\nmodule.exports.MyMiddleware extends OASBase {\n\n...\n\n/* Overridden */\nregister(app) {\n/* Do something */\napp.use(super.getMiddleware());\n}\n}","special-case-interceptors#Special case: Interceptors":"As explained in the Validation section, there is a special type of middleware that is capable of intercept responses and perform operations before they are sent to the client. We have called that type of middleware interceptors and they are created by overriding the default res.send() operation.When integrating more than one interceptor into the OAS Tools chain, you have to be aware that the order in which they will be executed is inverse to the order in which they are registered. The following flowchart describes this situation:\nflowchart LR\nSEND0([\"res.send()\"])\nSEND1([\"res.send1()\"])\nSEND2([\"res.send2()\"])\nSEND2-->|calls| SEND1-->|calls| SEND0\nSEND0-.-|modified by| I1\nI1-.->|produces| SEND1\nSEND1-.-|modified by| I2\nI2-.->|produces| SEND2\nI1(Interceptor 1)\nI2(Interceptor 2)\nstyle I1 stroke-width:3px\nstyle I2 stroke-width:3px\nAs shown in the graph, the first registered interceptor is Interceptor1, but the send1 function produced by it is executed after the function produced by Interceptor2, since the controllers will call res.send(), which is overriden by send2 function."}},"/docs/customization/project-setup":{"title":"Advanced project Setup","data":{"":"This section provides a more detailed approach on how to setup an OAS Tools project. Use the Configuration section to complement the information on this page.","adding-a-service-layer#Adding a service layer":"The service layer is an architectural pattern applied within the object-oriented programming paradigm, which goal is to provide a higher abstraction layer over application's bussiness logic.\nflowchart TB\nsubgraph servicelayer [Service layer]\nsubgraph domainmodel [Domain model]\nsubgraph datasource [Data source layer]\ndb[(   )]\nend\nend\nend\nstyle servicelayer rx:50,ry:50\nstyle domainmodel rx:35,ry:35\nstyle datasource rx:20,ry:20\nIn order to add a service layer in an OAS Tools service, create a directory containing your services and delegate the controlers' logic to them. The services must receive the request and response from the controllers. For example, the following controller would look like below when using a service layer:\n//Controller.js\n\nconst service = require('./service'); // import your service\n\nmodule.exports.controllerGet = function controllerGet(req, res) {\nservice.get(req, res); // Delegate functionality, passing req, res\n};\nThen, the corresponding service must export a get function that receives the request and response:\n//Service.js\n\nmodule.exports.get = function serviceGet(req, res) {\n/* Business logic here */\nres.status(200).send(/* Response body */)\n};","integrations#Integrations":"Since OAS Tools is a lightweight, flexible framework, many technologies may be integrated when developing a new service. Below are listed some of the most commons integrations when developing REST services.","express-body-parser#Express body parser":"OAS Tools is content agnostic, meaning it could receive JSON, XML or any other in request body as long as a body parser middleware is included in the first position of the middleware chain.\n//index.js\n\nconst http = require('http');\nconst app = require(\"express\");\nconst oasTools = require(\"@oas-tools/core\");\nconst app = express();\n\nconst xml = require('express-xml-bodyparser');\nconst multer = require('multer');\n\napp.use(express.json()); // JSON bodyparser\napp.use(express.urlencoded()); // URL encoded\napp.use(xml()); // XML bodyparser\napp.use(multer({/* multer config */})); // Multipart requests\n\nvar serverPort = 8080;\n\noasTools.initialize(app).then(() => {\nhttp.createServer(app).listen(serverPort, () => console.log(\"Server started!\"));\n})","databases#Databases":"OAS Tools architecture allows the integration with any database in the data source layer.","nosql-database---mongoose#NoSQL Database - Mongoose":"MongoDB is the most common database when it comes to developing services with Node.js. In order to connect to a mongo database we use mongoose, an OOP library that creates the connection between MongoDB and Node.js runtime environment. To integrate mongoose with OAS Tools, just create the connection before OAS Tools initialization, declare some models and use them in the controllers:\nInstall mongoose:\n\n\nnpm i --save mongoose\n\nCreate the database connection and initialize the server after it successfully connects:\n\n\n// index.js\n\nconst http = require('http');\nconst express = require(\"express\");\nconst oasTools = require(\"@oas-tools/core\");\nconst mongoose = require('mongoose');\n\n// Mongo connection variables\nconst mongoPort = process.env.MONGO_PORT ?? 27017;\nconst mongoHost = process.env.MONGO_HOST ?? 'localhost';\nconst mongoDBName = process.env.MONGO_DBNAME ?? 'defaultt-db';\nconst mongoURL = `mongodb://${mongoHost}:${mongoPort}/${mongoDBName}`;\n\nmongoose.connect(mongoURL).then(async () => {\nconst app = express();\nconst serverPort = 8080;\n\napp.use(express.json());\n\nawait oasTools.initialize(app)\nhttp.createServer(app).listen(serverPort, () => console.log(\"Server started!\"));\n})\n\nDeclare some mongo schemas:\n\n\n// User.js\n\nconst mongoose = require('mongoose');\nconst Schema = mongoose.Schema;\n\nconst UserSchema = new Schema(\n{\nname: {\ntype: String,\nrequired: true\n},\nbirthdate: {\ntype: Date,\nrequired: true\n}\n}\n);\n\nmodule.exports = mongoose.model('User', UserSchema);\n\nMake database queries in controllers:\n\n\n// UserController.js\nconst User = require('../models/User');\n\nmodule.exports.postUser = function post(req, res) {\nconst body = res.locals.oas.body;\nconst newUser = new User(body);\n\nnewUser.save().then(() => {\nres.status(201).send();\n}).catch((err) => {\nres.status(500).send({error: err});\n});\n};","prisma-orm#Prisma ORM":"Prisma is an Object Relational Mapping (ORM) software built for Node.js and Typescript. In the majority of cases it is used for connecting to relational databases, typically SQL, but it is also capable of making connection to non-relational databases like MongoDB. To integrate it with OAS Tools, create a folder containing the entrypoint for the prisma client and a file for the schemas:\nCreate prisma entrypoint\n\n\n// prisma/index.js\n\nconst { PrismaClient } = require('@prisma/client');\nmodule.exports = new PrismaClient();\n\nCreate schema.prisma file containing the models and the database connection URL, in this case we will connect to a PostgreSQL database:\n\n\n// prisma/schema.prisma\n\ngenerator client {\nprovider = \"prisma-client-js\"\nbinaryTargets = [\"native\"]\n}\n\ndatasource db {\nprovider = \"postgresql\"\nurl      = env(\"DATABASE_URL\") // environment variable\n}\n\nmodel User {\nid          Int @id @default(autoincrement())\nname        String  @db.VarChar(20)\nbirthDate   DateTime?\n}\n\nMake queries to the database in controllers\n\n\nconst prisma = require('../prisma');\n\nmodule.exports.postUser = function post(req, res) {\nprisma.user.create({\ndata: res.locals.oas.body\n})\n.then(rentals => {\nres.status(201).send();\n})\n.catch(err => {\nres.status(500).send({error: err});\n});\n};\n\nOptionally, you can add scripts in package.json to generate schemas and create migrations:\n\n\n// package.json\n\n{\n...\n\"scripts\": {\n\"generate-schema\": \"npx prisma generate\",\n\"prisma-migrate\": \"npm run generate-schema && npx prisma migrate deploy\",\n}\n}\n\nCheck the prisma documentation for more information about the possibilities that this library offers.","docker-containers#Docker Containers":"OAS Tools can run inside a container, since it is a Node.js service. In order to get the service running into a Docker container, some modifications must be made:\nYou can run npm init server <OAS Document> -d or select the Docker option when using the CLI interactive mode in order to get the service scaffolding for it to run inside Docker containers.\n\nMove the entrypoint code to a new server.js file:\n\n\n// server.js\n\nconst http = require('http');\nconst express = require(\"express\");\nconst oasTools = require('oas-tools');\n\nconst deploy = async () => {\nconst serverPort = 8080;\nconst app = express();\napp.use(express.json());\n\noasTools.initialize(app).then(() => {\nhttp.createServer(app).listen(serverPort, () => console.log(\"Server started!\"));\n});\n}\n\nconst undeploy = () => {\nprocess.exit();\n};\n\nmodule.exports = {\ndeploy: deploy,\nundeploy: undeploy\n}\n\nModify the service entrypoint:\n\n\n//index.js\n\nconst server = require('./server');\nconst env = process.env.NODE_ENV ? process.env.NODE_ENV : 'production';\n\nserver.deploy(env).catch(err => { console.log(err); });\n\n// quit on ctrl-c when running docker in terminal\nprocess.on('SIGINT', function onSigint () {\nconsole.log(`[${new Date().toISOString()}] Got SIGINT (aka ctrl-c in docker). Graceful shutdown`);\nshutdown();\n});\n\n// quit properly on docker stop\nprocess.on('SIGTERM', function onSigterm () {\nconsole.log(`[${new Date().toISOString()}] Got SIGTERM (docker container stop). Graceful shutdown`);\nshutdown();\n});\n\nconst shutdown = () => {\nserver.undeploy();\n};\n\nCreate a Dockerfile:\n\n\n# Dockerfile\n\nFROM node:16.13.0-alpine3.14\n\nWORKDIR /opt/app\n\nCOPY . .\n\nRUN npm install --only=prod\n\nARG NODE_ENV=production\nENV NODE_ENV $NODE_ENV\n\nARG PORT=80\nENV PORT $PORT\nEXPOSE $PORT\n\nCMD [ \"node\", \"index.js\" ]\n\nOptionally, create a .dockerignore:\n\n\n*Dockerfile*\n*docker-compose*\n*.log\n*.md\n.env*\n.git\n.github\ntests\nnode_modules\nOnce these changes are made, you can run docker build . and get your new container with OAS Tools."}},"/docs/features/error-handling":{"title":"Handling errors","data":{"":"OAS Tools internally uses custom error classes that are defined in the Commons library. Additionally, the framework has a built-in error handler that is active by default (middleware.error.disable is set to ´false´ in configuration).","built-in-handler#Built-in handler":"The built-in handler catches the errors produced during the execution flow along the middleware chain and produces a response based on the type of error that has been thrown. The folloing table contanis the description and the response produced by the handler for each error.\nError\tDescription\tHandler response\tRequestValidationError\tError thrown when the response content or content-type is invalid\t500 Internal Server Error or 406 Not Accepted\tSecurityError\tError thrown when missing required credentials\t401 Unauthorized\tAuthError\tError thrown when request credentials are invalid or lack privileges\t403 Forbidden\nOther classes, like ConfigError, UnsupportedError and RoutingError are not handled by the built-in middleware since they are thrown upon initialization and not during the request process.","extending-the-handler#Extending the handler":"As mentioned in the Configuration section, the built-in error handler may be extended by providing a custom function for handling new errors. That function is set in configuration and is executed right after the built-in handler.\n// oastools.config.js\n\nmodule.exports = {\nmiddleware: {\nerror: {\ncustomHandler: (err, send) => {\nif (err.name === \"JsonWebTokenError\") send(403);\n}\n}\n}\n}\nThe custom handler function must take two arguments: the error and a send function. The example above shows how to handle an error thrown by JWT Node.js library. The send function takes one mandatory argument, which is the status code of the response, and optionally can take the response body that will be sent to client.By default, the errors are sent to client as an object following the following format {error: \"<error name>: <error message>\" } but it can be overridden setting the second parameter in the send function received in the handler arguments.\nErrors are printed to console using the configured logger, if you want to use a custom logger check the custom logger section."}},"/docs/features/routing":{"title":"Routing","data":{"":"The routing middleware is registered in the last position of the middleware chain. It is in charge of loading the controllers and redirect the execution flow to the corresponding one depending on the request. Therefore, the controllers are part of the router middleware execution flow, and the res.send() function being called by them is the reason why this middleware must be registered last.\nflowchart LR;\nOAS-PARAMS(Parameter \\n Parser)\nOAS-SECURITY(Security \\nMiddleware)\nOAS-RQVALIDATOR(Request \\n Validator)\nOAS-RPVALIDATOR(Response \\n Validator)\nSEND([\"res.send( )\"])\nsubgraph OAS-ROUTER [Router Middleware]\nBUILTIN[Built-in middleware]\nCONTROLLERS[Controllers]\nBUILTIN-.->|loads| CONTROLLERS\nend\nOAS-PARAMS-->OAS-SECURITY\nOAS-SECURITY-->OAS-RQVALIDATOR\nOAS-RQVALIDATOR-->OAS-RPVALIDATOR\nOAS-RPVALIDATOR-->OAS-ROUTER\nOAS-RPVALIDATOR-.->|modifies| SEND\nCONTROLLERS-.->|calls| SEND\nstyle OAS-ROUTER stroke-width:3px,rx:5,ry:5","loading-controllers#Loading controllers":"Controllers are loaded upon initialization and stored in a in-memory map for redirecting to them on each request received by the API. There are two possibilities when it comes to loading controllers:\nLoading them through custom fields in the OpenAPI document.\nUsing experimental JSDoc annotations in controllers.\n\n\nThese options can't be combined. For consistency reasons, you must stick to one of them.","through-openapi-document#Through OpenAPI document":"This is the predetermined option, since useAnnotations is disabled by default in configuration. It uses custom attributes on the OpenAPI document to redirect to the correct controller each time. However, OAS Tools provides an auxiliary function capable of generate names in case those attributes are not set.","default-controller-names#Default controller names":"When there are no attributes in the OpenAPI document that specify user defined names for controllers or operations, OAS Tools generates a name for them:\nFor controllers, the generated has the following format {endpoint}Controller removing the endpoint slashes /\nFor methods, similarly to controllers, the generated name format is func{endpoint} removing endpoint slashes.\n\nFor example, assuming the following OpenAPI document:\nopenapi: 3.0.0\ninfo:\nversion: 1.0.0\ntitle: Quickstart\ndescription: Quickstart for OAS-Tools\npaths:\n/api/v1/entity:\nget:\nresponses:\n'200':\ndescription: Success\ncontent:\napplication/json:\nschema:\ntype: object\nThe generated name for the controller handling /api/v1/entity endpoint would be apiv1entityController, and the operation name for the GET would be funcapiv1entity. That way, when making a GET request to {server}/api/v1/entity, the execution flow would be redirected to the funcapiv1entity inside {controllers}/apiv1entityController.js.","x-router-controller#x-router-controller":"The x-router-controller property can be added at the path level or at the operation level of an OpenAPI declaration. When declared at path level, all operations for that path will be redirected to the specified controller unless different is specified through x-router-controller at the operation level. That means the operation level overrides what is specified on the path level. The following example describes this situation:\nopenapi: 3.0.0\ninfo:\nversion: 1.0.0\ntitle: Quickstart\ndescription: Quickstart for OAS-Tools\npaths:\n/api/v1/entity:\nx-router-controller: EntityController # Path level\nget:\nresponses:\n'200':\ndescription: Success\ncontent:\napplication/json:\nschema:\ntype: object\npost:\nx-router-controller: DifferentController # Operation level\nresponses:\n'201':\ndescription: Success\nUsing the above declaration, when making a GET request to /api/v1/entity, the control flow would be redirected to funcapiv1entity inside EntityController.js since the default controller name is overriden by the x-router-controller at the path level. However, when making a POST request to the same endpoint, the router middleware would redirect to DifferentController because the operation level has priority over the path level x-router-controller property.","operation-id#Operation Id":"The default names don't work well when having multiple operations on the same path, since the generated name would be the same for all of them and therefore the same function would be handling multiple REST operations in a controller. That's where the operationId attribute takes action. OAS Tools read the operationId from each of the operations declared for a path and loads the function with that name in the corresponding controller, preventing a single function handling multiple operations for a path.\nopenapi: 3.0.0\ninfo:\nversion: 1.0.0\ntitle: Quickstart\ndescription: Quickstart for OAS-Tools\npaths:\n/api/v1/entity:\nx-router-controller: EntityController\nget:\noperationId: getEntity\nresponses:\n'200':\ndescription: Success\ncontent:\napplication/json:\nschema:\ntype: object\npost:\noperationId: postEntity\nresponses:\n'201':\ndescription: Success\nWhen making a GET request to /api/v1/entity endpoint of an OAS Tools server implementing the functionality for the above OpenAPI declaration, the Router middleware would redirect the traffic to getEntity function inside EntityController.js.","through-jsdoc-annotations-experimental#Through JSDoc annotations (Experimental)":"This feature is experimental and may suffer changes or be completely removed or replaced by Javascript decorators in future versions. Feedback is appreciated!\nIn order to use this feature, you first need to enable it through configuration: useAnnotations = true. Once enabled, you will be able to write JSDoc style annotations to configure your project's operation. Read more about JSDoc annotations in the JSDoc documentation. The next sections describe predefined annotations that can be used to configure routing.","the-controller-annotation#The Controller annotation":"This annotation will tell the router middleware that the current file is a controller that handles request for some endpoint path. It must be placed in the first line of the file with the following format: @oastools {Controller} <path>.Using this approach, it is no longer necessary to name your controllers in a certain way. However is is still necessary to place them under the {controllers}/ directory set in configuration. For example, the following file would be identified as a controller handling requests to /api/v1/users:\n// controllers/randomName.js\n\n/** @oastools {Controller} /api/v1/users */\n\nconst someDependency = require('whatever');\n...","the-method-annotation#The Method annotation":"This annotation must be used on top of function declarations. It tells the framework which type of request is handled by the annotated function. Just like with controller annotation, this annotations makes no longer necessary to name the functions a certain way. The format followed by the method annotation is: @oastools {method} <METHOD>, for example:\n// controllers/randomName.js\n\n/** @oastools {Controller} /api/v1/users */\n\n/**\n* @oastools {method} GET\n*/\nmodule.exports.someFunction = function aGetRequest(req, res) {\n/* Do something */\n};\nThe code above would be identified as a GET handler for /api/v1/users. This way, when making a GET request to that endpoint, the router middleware will execute that function.","the-path-annotation#The Path annotation":"The path annotation allows to attach a subpath to the controllers path. It is useful when the endpoint takes parameters in the path. It is formatted as @oastools {path} <subpath>, for example:\n// controllers/randomName.js\n\n/** @oastools {Controller} /api/v1/users */\n\n/**\n* @oastools {method} GET\n* @oastools {path} /{id}\n*/\nmodule.exports.someFunctionWithId = function aGetRequestWithId(req, res) {\n/* Do something */\n};\nThe function declared above would handle GET requests to /api/v1/users/{id}, since the /{id} subpath has been specified by the annotation."}},"/docs/features/security":{"title":"Security","data":{"":"This feature is not compatible with Node.js versions before 15.0.0","security-schemes#Security schemes":"Security schemes allow you to secure you API by describing protection rules under securitySchemes and apply them to some endpoints, operations or to the whole API service. The following schemes are available in the OpenAPI specification 3.X:\nHTTP authentication (using the Authentication header)\nBasic authentication\nBearer authentication\n\n\nApi keys in headers, query or cookies\nOAuth2\nOpenIDConnect\nMutualTLS (3.1 only)","declaring-schemes#Declaring schemes":"To declare a security scheme, use the securitySchemes keyword under components section on your OpenAPI declaration, like shown:\n...\ncomponents:\nsecuritySchemes:\n\nBasicAuth:\ntype: http\nscheme: basic\n\nBearerAuth:\ntype: http\nscheme: bearer\n\nApiKeyAuth:\ntype: apiKey\nin: header\nname: X-API-Key\n\nOpenID:\ntype: openIdConnect\nopenIdConnectUrl: https://example.com/.well-known/openid-configuration\n\nOAuth2:\ntype: oauth2\nflows:\nauthorizationCode:\nauthorizationUrl: https://example.com/oauth/authorize\ntokenUrl: https://example.com/oauth/token\nscopes:\nread: Grants read access\nwrite: Grants write access\nadmin: Grants access to admin operations\nThe snippet above declares all possible types of authentication as described in the OpenAPI specification. More information on each authentication type and its configuration options can be found at the OpenAPI documentation.","applying-schemes#Applying schemes":"Security can be applied to the whole API or to one or more operations separately by adding the security keyword on the root level or the operation level, respectively. When used on the root level, security applies the specified security schemes globally to all API operations, unless overridden on the operation level:\nopenapi: 3.0.0\ninfo:\n...\n\nsecurity:\n- BasicAuth: []\n\npaths:\n/api/v1/endpoint:\nget:\nsecurity:\n- BearerAuth: []\n...\nIn the example above, we are applying the BasicAuth scheme declared in the previous section to the whole API, but it is getting overriden by BearerAuth declared on the operation level. This way, when making a request to /api/v1/endpoint, only the BearerAuth will be required.It is possible to apply multiple schemas at once, and set if they are all required or not. Complex requirements can be done through logical AND and logical OR operations that are declared as described in the following sections.\nAlthough multiple schemas of different types can be combined, the API must be consistent: You can't use HTTP Bearer and HTTP Basic authentication at the same time, since both use the Authentication header. The same happens when declaring multiple api keys, they must be set in different query or cookie params, or in different headers.","logical-and#Logical AND":"When applying multiple schemas, you tipically want all of them to be satisfied in ordet for a request to succeed. To do that, the schemes must be specified as an object inside the security propery in the OpenAPI document.\nsecurity:\nBasicAuth: []\nApiKeyAuth: []\nThis way, according to the snippet above, to make a request and obtain a successful response we would need to provide a basic authentication in the Authentication header AND an api token in the X-Api-key header (as declared in the scheme before).","logical-or#Logical OR":"When many schemes are defined, you probably want to emit a successful response when any of them is provided in the request. To do so, the schemes must be specified as an array inside the security property in the OpenAPI declaration.\nsecurity:\n- BasicAuth: []\n- ApiKeyAuth: []\n- OpenId: [read]\n- OAuth2: [write]\nTo get a successful request from a server with the security declaration above we would just have to provide one of the types specified, either Basic auth, an api key OR authenticate through OAuth or OpenIDConnect.\nNOTE that OpenID and OAuth2 are scoped (read and write), read more about scopes in the OpenAPI documentation.","security-handlers#Security Handlers":"When the security middleware is enabled in configuration and security schemes are specified under components in the OpenAPI declaration, you need to provide a handler to each one of the security schemes. If a handler is missing or no security schemes are defined, an error will be thrown upon initialization.Security handlers are functions that implements the desired logic for handling the security schemes, like validating an api key token for an apikey type scheme. They are set in the configuration under middleware.security.auth.<handler> and the handler name must match the security schemes that is being handled:\n// oastools.config.js\n\nmodule.exports = {\nmiddleware: {\nsecurity: {\nauth: {\nBasicAuth: (token) => {/* Validate encoded token*/ },\nBearerAuth: (token) => {/* Validate token */ },\nApikeyAuth: (token) => {/* Validate the token */ },\nOAuth2: (secDef, secScope) => { /* OAuth authentication */ },\nOpenID: (secDef, secScope) => { /* OAuth authentication */ }\n}\n}\n}\n}\n\nNote that HTTP and Apikey authentication receive the token provided to validate in the arguments, while OAuth2 and OpenID receive the security scheme definition and the scopes array.\nThe handler function may return a result, typically the decoded token in case of HTTP Authentication. This result is saved to res.locals.oas.security.<handler> in order to make it available to controllers later in the execution."}},"/docs/features/swaggerUI":{"title":"Swagger UI","data":{"":"This feature is not available when using OpenAPI 3.1","overview#Overview":"The swagger UI is active by default in configuration. You may turn it off or configure it to be displayed in a different route (default is /docs).This integration of the swagger interface consists in a middleware class wrapping the swagger-ui-express package. This way, OAS Tools is able to integrate it inside its middleware chain and extend its configuration adding new options, such as the possibility of hiding endpoints from the swagger documentation.","configuration#Configuration":"Thanks to the OAS Tools integration of the SwaggerUI, many configuration options are available across the project. Some of the posibilities are listed below.","hiding-endpoints#Hiding endpoints":"OAS Tools offers the possibility to hide determined endpoints from the swagger interface, depending on whether the experimentals JSDoc annotations are enabled or not:","through-the-openapi-document#Through the OpenAPI document":"In order to hide one or more operation from the swagger documentation, you need to add x-swagger-ui: false at the operation level of the OpenAPI document.\n...\nget:\nx-swagger-ui: false\ndescription: Some endpoint's operation\nresponses:\n...","using-annotations-experimental#Using annotations (Experimental)":"When experimental JSDoc annotations are enabled, operations can be hidden just by adding the @oastools {swaggerUI} false annotation on top of the controller operation you want to hide.\n/**\n* @oastools {method} POST\n* @oastools {swaggerUI} false */\nmodule.exports.createUser = function createUser(req, res) {\nvarUserController.createUser(req, res);\n};","customcss#CustomCSS":"The custom CSS is a feature already included in the express-swagger-ui package wrapped inside OAS Tools swagger middleware. You can sett customCSS from the global server configuration, under middleware.swagger.ui.customCSS:\n// .oastoolsrc\n\n{\n\"middleware\": {\n\"swagger\": {\n\"ui\" : {\n\"customCss\": \".swagger-ui .topbar { background-color: blue }\"\n}\n}\n}\n}\nThe example above would result in a swagger interface with a blue topnav:","more-options#More options":"More options are inherited from swagger-ui-express npm package. Please visit their documentation to know all the possible config options."}},"/docs/features/validation":{"title":"Validation","data":{"":"The errors thrown by validator middleware explained in the Request Validation and Response Validation sections in this page are handled by the built-in error handler and therefore the status code that the server sets for the responses when validation is strict depends on it being enabled.","openapi-file-validation#OpenAPI file validation":"OAS Tools is capable to validate an OpenAPI document thanks through the Commons library. OAS Tools' commons integrates AJV JSON Schema validator, wrapped in two functions that validates the whole document or a part of it.Being the validator integrated in Commons, it is reusable and can be called from different middlewares and tools, such as the CLI or the request and response validator middlewares.OAS Tools perform a validation of the complete OpenAPI document upon initialization in order to avoid errors caused by the document not being valid towards the correspondent version of the OpenAPI schema. In case the file is not valid, AJV validations error are pretty printed through the built-in logger.This would be the output when missing the required property 'title' inside info:\n2022-08-13 12:08:74 [oas-tools] ERROR: ValidationError: Specification file does not meet OpenAPI 3.0.0 schema.\n- Validation failed at /info > must have required property 'title'","request-validation#Request validation":"The request validation is a middleware function that relies on the common's library validation functions to check specific parts of the OpenAPI document, more precissely, it checks parameters andrequest body against OpenAPI schema declaration.","parameters#Parameters":"The parameters are validated for each request depending on what has been specified for that operation:\n...\n/endpoint/{id}:\nget:\nparams:\nparameters:\n- name: id\nin: path\nrequired: true\nschema:\ntype: integer\n...\nIn the snippet above we have defined a GET request that gets one required parameter named id. If we made a GET request to {server-url}/endpoint we would get a warning on console (or an error message if strict validation has been toggled on in configuration) telling that there has been a validation error due to the parameter id being required. The same would happen if we specified a non-integer id, since it is specified to be such type.\nStrict validation causes the server to respond 400 Bad Request when request validation fails.\n\n2022-08-13 12:08:64 [oas-tools] WARN: Parameter id does not match the schema specified in the OAS Document:\n- Validation failed at #/type > must be integer","request-body#Request body":"Similarly to how parameters validatio works, the request body is validated through the commons library validation functions.\n...\npost:\nrequestBody:\ndescription: Body of the request\nrequired: true\ncontent:\napplication/json:\nschema:\ntype: object\n...\nIn this case, we are defining a post request whith a required content body in which an object must be included formatted as JSON. If we made a POST request without including the body or including non-object content, then the server would print a warning on console or in case strict validation is active, respond with 400 Bad Request.","response-validation#Response validation":"The response validation middleware is a special function capable of intercepting responses, validate them and then sending them to the client. Even if this function has performs validation after res.send() is executed, it must be registered in the middleware chain before res.send() is called, that is why it is registered before the router middleware (check out the diagram in the routing section):\nflowchart LR;\nOAS-PARAMS(Parameter \\n Parser)\nOAS-SECURITY(Security \\nMiddleware)\nOAS-RQVALIDATOR(Request \\n Validator)\nOAS-RPVALIDATOR(Response \\n Validator)\nOAS-ROUTER(Router \\n Middleware)\nOAS-PARAMS-->OAS-SECURITY\nOAS-SECURITY-->OAS-RQVALIDATOR\nOAS-RQVALIDATOR-->OAS-RPVALIDATOR\nOAS-RPVALIDATOR-->OAS-ROUTER\nstyle OAS-RPVALIDATOR stroke-width:3px","intercepting-responses#Intercepting responses":"As explained above, the response validator is registered before the router middleware that calls res.sen() through controllers. However, this middleware is an interceptor, meaning it must read the responses sent to client, validate the content and send a new response to the client (or the same if it is valid).In order for this middleware to intercept responses, the res.send() function is overriden in a way that the validations are performed in the first place, and then the original send function is called:\nconst oldSend = res.send;\nres.send = (response) => {\n/* response validation */\n\noldSend.call(res, newResponse);\n}","validating-content#Validating content":"In case of the response content, not only it is necessary to validate the content itself against the schema, but also check that the content-type matches the Accept header set in requests.The response content is validated just like the request body before. Its declaration must exist under the responses field of each operation specified in the OpenAPI document. Then the middleware will check the data against the schema before it is sent to the client, and print a warning or error message (when strict is active) in case the content is not valid.\nIf strict is active and the server throws a response validation error due to invalid content, it will respond with a 500 Internal server error since the responses are set in the server controllers and therefore, it is a server error.\nThe middleware will also check the response content-type MIMEType against the Accept header set in request, that way if the response content-type is not accepted and validation is set to strict, the server will respond with 406 Not Accepted, else it will print a warn message. In case no Accept header is provided in the request, then the server will assume */* as any content type is valid as a response for that request.\nIf no content-type is set for response, OAS Tools will assume it is application/json;charset=utf-8."}},"/docs/fundamentals/business-logic":{"title":"Business logic","data":{"":"The business logic layer in OAS Tools is implemented through controllers that are loaded by the router middleware upon initialization. The routing section describes how controllers are loaded and how it can be altered to redirect to other controllers. By default, each path declared in the OpenAPI document will have a controller to handle its requests.","controllers#Controllers":"The controllers are functions that receive the request and response objects from express in order to perform an operation and return a result through res.send() or res.status().send().When writing a controller you should take into account the name of the exported function (more details in the routing section) and the operation that will be performed.\nGET operations typically receive some parameters. Since controllers receive req and res objects from express, you can access parsed parameters from res.locals.oas.params or in case you want to wark with the raw types received by express you can use req.params instead.\nPOST and PUT operations receive a request body. Just like with paramaters, the body is accesible from res.locals.oas.body or req.body.\nSome request may include multipart content. This content will be available at res.locals.oas.files or as long as a multipart bodyparser is included in the middleware chain.\n\n\nOAS Tools is content agnostic, meaning it could receive JSON or XML in request body as long as a body parser middleware is included in the first position of the middleware chain. Check out the advanced project setup for more information about possible integrations with other technologies.\n\n// UserController.js\n\nmodule.exports.postUser = function post(req, res) {\nconst params = res.locals.oas?.params;\nconst body = res.locals.oas?.body;\nconst files = res.locals.oas?.files;\n\n/* Perform some operation, like saving to a database */\n\nres.status(201).send();\n};"}},"/docs/fundamentals/config":{"title":"Configuration","data":{"":"OAS Tools v3 can read the v2 options and parse them. However, some of the new features will not be available if using the v2 initialization. Check the Compatibility page for more information","options#Options":"","general-config#General config":"This options are set at the root level of the configuration object. They are general purpose options that affect mainly the initialization of the framework.\nOption\tType\tDefault\tDescription\tpackageJSON\tString\t./package.json\tPath to where the package.json file is located\toasFile\tString\t./api/oas-file.yaml\tPath to where the main OpenAPI document is located\tuseAnnotations (Experimental)\tBoolean\tfalse\tThis feature is experimental. Toggles JSDoc like annotations. Check the routing section for more information","logger-config#Logger config":"This options affect the default logger integrated within the OAS Tools core library. They are set under the logger key in the configuration object.\nOption\tType\tDefault\tDescription\tcustomLogger\tObject\tnull\tCustom logger to override the built-in one. Must be a winston instance. Setting this option causes to ignore the rest.\tlevel\tString\tinfo\tLevel of the logs that are printed to console\tlogFile\tBoolean\tfalse\tWhether to save the logs to a file or not.\tlogFilePath\tString\t./logs/oas-tools.log\tPath where the log file is saved. Ignored if logFile is false.","middleware-config#Middleware config":"This options are set under middleware.<middleware name>. They set the configuration for each of the built-in middleware function of OAS Tools.\nOption\tType\tDefault\tDescription\trouter.disable\tBoolean\tfalse\tToggles Router middleware.\trouter.controllers\tString\t./controllers\tPath to the controllers directory.\tvalidator.requestValidation\tBoolean\ttrue\tToggles Request validation.\tvalidator.responseValidation\tBoolean\ttrue\tToggles Response validation.\tvalidator.strict\tBoolean\tfalse\tWhen active, throws an error upon validation errors. In other case, prints a warn message.\tsecurity.disable\tBoolean\ttrue\tToggles security  middleware.\tsecurity.auth\tObject\tnull\tObject containing the handler functions for the security schemes. Check the security section for more information.\tswagger.disable\tBoolean\tfalse\tToggles SwaggerUI.\tswagger.path\tString\t/docs\tPath where the SwaggerUI will be displayed.\tswagger.ui\tObject\tnull\tCustom configuration for the Swagger interface. Check swagger-ui package docs for more information.\terror.disable\tBoolean\tfalse\tToggles the built-in error handler.\terror.printStackTrace\tBoolean\tfalse\tPrints the full trace when an error is thrown.\terror.customHandler\tFunction\tnull\tFunction to extend the built-in handler. Check the error handler section for more information.","setting-configuration#Setting configuration":"Configuration for OAS Tools can be set in multiple ways, why is why we have established a preference order for the possible configuration sources:\nflowchart RL;\ndefault(Default config)\npjson(Package.json config)\nrc(rc config)\nobj(config object)\nobj-- overrides -->rc-- overrides -->pjson-- overrides -->default","using-packagejson#Using package.json":"Configuration can be set in the package json under the oas-tools keyword. For example if we wanted to disable error handling and set the logger level to debug:\n// package.json\n\n{\n\"oas-tools\": {\n\"logger\": { \"level\": \"debug\" },\n\"middleware\": { \"error\": { \"disable\": true } }\n}\n\n...\n}","using-rc-config#Using rc config":"The rc config uses the rc config loader to load the configuration from multiple sources, following precedence order. Although it allows setting configuration from environment variables or global config files at /etc or $HOME/config, typically you'll want to use a local file located in your proyect root. That file must be named .oastoolsrc and can be written using ini or JSON syntax:\n// .oastoolsrc\n{\n\"oasFile\": \"api/main.yaml\",\n\"logger\": { \"level\": \"off\" }, // setting off or false to logger level deactivates it\n\"useAnnotations\": true,\n\"middleware\": {\n\"validator\": {\n\"strict\": true\n}\n}\n}","passing-an-object#Passing an object":"Finally, you can pass a configuration object directly to the OAS Tools initialization function. This approach is best when you require declaring function like security handlers or custom logger classes.\nTake into account that this approach has the maximum priority and will override any other configuration previously set through any other means.\n\n// index.js\n\nconst http = require('http');\nconst express = require(\"express\");\nconst oasTools = require(\"@oas-tools/core\");\nconst app = express();\n\napp.use(express.json());\nvar serverPort = 8080;\n\nconst config = {\nmiddleware: {\nsecurity: {\ndisable: false,\nauth: {\napikey: (token) => { /* ApiKey security handler */ }\n}\n}\n}\n}\n\noasTools.initialize(app, config).then(() => {\nhttp.createServer(app).listen(serverPort, () => console.log(\"Server started!\"));\n})\nIn case you need to set complex config options, or your entrypoint file readibility is being compromised, it is a good practise to declare the configuration in a separate file, like so:\n// oastools.config.js\n\nmodule.exports = {\nmiddleware: {\nsecurity: {\ndisable: false,\nauth: {\napikey: (token) => { /* ApiKey security handler */ }\n}\n}\n}\n}\nAnd then import it in the entrypoint file:\n// index.js\n\nconst http = require('http');\nconst app = require(\"express\");\nconst oasTools = require(\"@oas-tools/core\");\nconst config = require(\"./oastools.config.js\");\n\nconst app = express();\n\napp.use(express.json());\nvar serverPort = 8080;\n\noasTools.initialize(app, config).then(() => {\nhttp.createServer(app).listen(serverPort, () => console.log(\"Server started!\"));\n})"}},"/docs/fundamentals/openapifile":{"title":"OpenAPI file","data":{"":"The OpenAPI document is the cornerstone of the OAS Tools framework, since it contains de declaration of the API service that is being implemented. By default the framework searches for it under the /api directory.The following sections describes the minimal fields the OpenAPI document must contain in order to work with OAS Tools.","basic-oas-document#Basic OAS Document":"The sections below are meant to be a basic guide on how to write a minimal OpenAPI declaration. There are plenty of more options, fields and parameters that can be added to the document. Check out the OpenAPI spec docs for more information.","openapi-version#OpenAPI version":"OAS Tools supports OpenAPI version 3.0 as well as 3.1. That version is specified on the root level under the openapi field, like shown:\nopenapi: 3.0.3 # allows 3.0.X and 3.1.X\ninfo: ...\nThere are some differences between version 3.0 and 3.1, mainly because of the compatibility with JSON schema. Some of the differences are described below. Read this article by the OpenAPI mantainers to know all the differences between both versions.","openapi-30#OpenAPI 3.0":"It is based on JSON Schema Draft 05.\nOnly one type can be specified within the type field under a schema definition, making necessary the use of nullable keyword when a type could be null.\n\n\n# OpenAPI 3.0\n\nschema:\ntype: string\nnullable: true","openapi-31#OpenAPI 3.1":"It is based in the latest JSON Schema version, Draft 2020-12. Since OpenAPI is a superset built over JSON Schema, all the features in this draft are now usable in the OpenAPI declaration.\nMultiple types can be specified inside an array within the type field, making nullable redundant.\n\n\n# OpenAPI 3.1\n\nschema:\ntype:\n- 'string'\n- 'null'\n\nOpenAPI is entirely compatible with JSON Schema because it is now a JSON Schema dialect, so by default any schema is using $schema: \"https://spec.openapis.org/oas/3.1/dialect/base\" dialect. If you split your schemas into other JSON/YAML files and use $ref to point to them, they could contain a different $schema and override this default, making it easier for mantainers since now schemas can reference the draft they are based on.\n\n\n{\n$schema: \"http://json-schema.org/draft-07/schema#\",\n}","info-object#Info object":"This object is required in the OpenAPI schema. It provides metadata information about the service that is being described. That metadata must contain title and service version, and optionally it may contain a description, contact information, the license and the terms of use.\ninfo:\ntitle: Your API name\nversion: \"v1.0.0\" # The version of your API, not OpenAPI version\ndescription: OPTIONAL description\ntermsOfService: OPTIONAL URL to the terms of service\ncontact: # OPTIONAL contact object\nname: ISA\nurl: https://isa.us.es\nemail: isa@example.us.es\nlicense: # OPTIONAL license object\nname: MIT\nurl: https://opensource.org/licenses/MIT","paths-object#Paths object":"This object contains the paths for each of the endpoints that the API has. Each path contains an object that describes the service operations (GET, POST, PUT, DELETE...) or a reference to it.For each operation described, it is required to specify a description and the responses the server may give to that operation. You may also include a description of the params or the request body, if any.\npaths:\napi/v1/entity:\n$ref: entity-doc.yaml # Reference to other file\napi/v1/entity/{id}:\ndelete:\ndescription: Removes entity by id\nresponses:\n204:\ndescription: Entity removed","showcase#Showcase":"Knowing the basics of the OpenAPI declaration, we could wrap up all the sections above to try declare an API service with the following specs:\nOpenAPI version 3.1\nService name should be OpenAPI server, version v1.0.0-beta.1\nMIT licensed\nOne resource, called Users, with GET, POST and DELETE operations\nCreate one file for the Users only\nUsers may be null\n\nTo meet these requirements, we first need to create two files. We will create a file named main.yaml that contains the general API declaration, and anothr file user-doc.yaml that contains the endpoint declaration for the Users resource.\n# main.yaml\n\nopenapi: 3.1.0\ninfo:\ntitle: OpenAPI server\nversion: \"v1.0.0-beta.1\"\nlicense: # OPTIONAL license object\nname: MIT\nurl: https://opensource.org/licenses/MIT\npaths:\n/api/v1/users:\n$ref: user-doc.yaml#/api-v1-users\n/api/v1/users/{id}:\n$ref: user-doc.yaml#/api-v1-users-id\nThen we write the user endpoints declaration in a separate file:\n# user-doc.yaml\napi-v1-users:\nget:\ndescription: Get all the users\nresponses:\n'200':\ndescription: Success\ncontent:\napplication/json:\nschema:\ntype: array\nitems:\n$ref: '#/components/user'\n\npost:\ndescription: Creates a new user\nrequestBody:\ndescription: User object\nrequired: true\ncontent:\napplication/json:\nschema:\n$ref: '#/components/user'\nresponses:\n'201':\ndescription: Success\n\napi-v1-users-id:\ndelete:\ndescription: Deletes user by id\nparameters:\n- name: id\ndescription: User's id\nin: path\nrequired: true\nschema:\ntype: integer\nresponses:\n'204':\ndescription: Success\n\n# Declare a components section for reusability\ncomponents:\nuser:\nschema:\ntype: [ \"object\", \"null\" ]\nNow the service has been declared according to the requirements, try using the CLI to generate the code and test it out!"}},"/docs/getting-started/overview":{"title":"Overview","data":{"":"This is the OAS Tools v3 documentation\nOAS Tools v2 docs can be found at GitHub Readme.\nUpgrading from OAS Tools v2? Check out the Migration guide.","what-is-oas-tools#What is OAS Tools?":"OAS Tools is a lightweight server-side framework built over Express.js in order to create REST services that meet a declaration written following the OpenAPI specification.The OAS Tools ecosystem is formed by the Core package, the Commons library, the command-line interface tool and External Modules, that interact with each other like shown below:\nflowchart LR;\nResource(Entity \\n Resource)\nOASDoc(OpenAPI \\n Document)\nCLI(CLI)\nsubgraph NodeServer [Node.js Server]\ndirection LR\nCore(Core) --> ExtModule(External \\n Modules)\nExtModule --> Commons(Commons \\n Library)\nCore --> Commons\nend\nResource --> CLI\nOASDoc --> CLI\nCLI --> NodeServer\nstyle NodeServer rx:10,ry:10\n\nOAS Tools core contains modules capable of performing validation and routing operations that provide the required functionality for an HTTP server to work according to what has been specified in the OpenAPI document.\nThe Commons library contains auxiliary function and classes that help develop new modules which are easily integrable inside the OAS Tools ecosystem. Those modules are classes wrapping a middleware function that get registered in the underlying Express chain. Check out the customization section for a more in depth explanation on how to develop and install external modules.\nThe CLI allows the user to quickly create new REST services with OAS Tools core under the hood. Besides, the CLI provides functions to create new external modules from the OpenAPI document or even an entity resource. A full workspace with all the tools required for developing the project can be also generated through the command line. Check out the CLI documentation for more info.","middleware-chain#Middleware chain":"The OAS Tools core library provides a number of middleware functions that get registered under the Express.js middleware chain. Those middleware get registered for every path specified in the OpenAPI document, except for the Swagger Interface and the Error Handler, which get registered under different paths.\nflowchart LR;\nREQUEST[Request]\nOAS-PARAMS(Parameter \\n Parser)\nOAS-SECURITY(Security \\nMiddleware)\nOAS-VALIDATOR(Request/Response \\n Validation)\nOAS-ROUTER(Router \\n Middleware)\nERRORH(Error \\n Handler)\nSWAGGERUI(Swagger \\n Interface)\nREQUEST -- /path --> OAS-PARAMS\nREQUEST -- /docs --> SWAGGERUI\nREQUEST -- / --> ERRORH\nOAS-PARAMS-->OAS-SECURITY\nOAS-SECURITY-->OAS-VALIDATOR\nOAS-VALIDATOR-->OAS-ROUTER\nThe functions registered under /{path} are the ones that provide the functionality to the OpenAPI v3 features, whereas the SwaggerUI and the Error handler are used for documentation and catching errors, respectively.\nParameter parser: Supports OpenAPI 3.X parameter serialization, it is capable of read the parameters (including the body) specified for each path and parse them to the type specified in the schema field. Once the parameters are read an converted, it passes them to Express' res.locals in order to make them available for the next middleware execution.\nSecurity middleware: It is responsible for validating security schemes specified in the OpenAPI document. By default, it checks for existence, but further validations can be done through handler functions. Check the security section for more information.\nValidator: Performs validation to request and responses according to what has been declared in the OpenAPI document. It relies in AJV JSON Schema validator. Check the validation section for a more in depth explanation on how request and responses are validated.\nRouter: It is in charge for redirecting the execution flow to the corresponding controller. The routing section explains how routing is done."}},"/docs/getting-started/quickstart":{"title":"Quickstart","data":{"":"","using-the-cli#Using the CLI":"The command line interface incorporates the necessary functionality to initialize a REST service from an OpenAPI document as well as to initialize it from an entity resource.To initialize the CLI tool, run the following command (without the > sign):\n> npx @oas-tools/cli init\nIt will prompt the following menu, asking which type of resource will be initialized:\n? Select a resource to initialize (Use arrow keys)\n> Server\nModule\nDevelopment environment\nOpenAPI File","staring-from-an-entity-resource#Staring from an entity resource":"In order to initialize a REST service from an entity resource, you will first need to generate a valid OpenAPI document. Your entity resource must be written in a YAML or JSON file and should look like this:\n[\n{\n\"id\": 1,\n\"name\": \"User\",\n\"email\": \"user@example.com\"\n},\n{\n\"id\": 1,\n\"petName\": \"Garfield\",\n\"type\": \"Cat\"\n}\n]\n\nNote that in the example above we have declared an array containing two types of resources: A User with id, name and email attributes, and a Pet with id, petName and type attributes. OAS Tools CLI is capable of interpret both resources and generate a valid OpenAPI document. In case only one resource is provided, there is no need to declare it as an array, an object can be directly passed to the CLI, too.\nOnce your resource file is ready, select the fourth option in the menu prompted after running npx @oas-tools/cli init command before.\n? Select a resource to initialize (Use arrow keys)\nServer\nModule\nDevelopment environment\n> OpenAPI File\nIt will ask you for your resource file, navigate to the directory it is in and select it. Then it will read your file and ask some questions about it.\n? Select your resources file '/testResource.json'\n? Choose OpenAPI version '3.1'\n? Enter a title for the described API 'Autogenerated Api'\n? Enter a description for the described API 'Generated with OAS TOOLS CLI'\n? Provide a name for the resource containing {id,name,email} 'User'\n? Which will be the id property for User 'id'\n? Specify which operations will be available for User 'GET, POST, PUT, DELETE'\n? Provide a name for the resource containing {id,petName,type} 'Pet'\n? Which will be the id property for Pet 'id'\n? Specify which operations will be available for Pet 'POST, DELETE'\n? Choose the preferred format for the OpenAPI Document 'YAML'\n? Where will be file generated? 'oas-doc.yaml'\n? Generate file with this options? (Y/n)\nOnce all the question has been answered, a new OpenAPI file will be generated with the name specified. After that, follow the steps in the section below to generate a server from the OpenAPI declaration.","starting-from-the-openapi-document#Starting from the OpenAPI document":"Having a valid OpenAPI document, select the first option in the menu prompted after running npx @oas-tools/cli init command:\n? Select a resource to initialize (Use arrow keys)\n> Server\nModule\nDevelopment environment\nOpenAPI File\nIt will ask the following questions about the generated server:\n? Where will be files generated? 'generated-server'\n? Port in which the server will be listening '8080'\n? Specify the path to the OpenAPI Document 'oas-doc.yaml'\n? Choose the preferred format for the OpenAPI Document 'YAML'\n? Dereference OpenAPI document? 'No'\n? Choose the preferred Javascript convention for your server 'ECMAScript Modules (ESM)'\n? Will the server run inside a container? 'Run normally'\n? Compress files in ZIP and delete? 'No'\n? Generate server with this options? (Y/n)\nOnce the server is generated, you can cd <generated-server> and run:\n> npm start","without-using-the-cli#Without using the CLI":"Assume the following OpenAPI document, save it to oas-file.yaml:\nopenapi: 3.0.0\ninfo:\nversion: 1.0.0\ntitle: Quickstart\ndescription: Quickstart for OAS-Tools\npaths:\n/api/v1/entity:\nget:\nx-router-controller: EntityController\noperationId: getEntity\nresponses:\n'200':\ndescription: Success\ncontent:\napplication/json:\nschema:\n$ref: '#/components/schemas/entity'\ncomponents:\nschemas:\nentity:\ntype: object\nStart by creating a new Node.js project and install express and OAS Tools core:\n> npm init\n> npm install --save express @oas-tools/core\n\nIf you want to use ESM syntax, insert \"type\": \"module\" at the root level into the generated package.json. Note that OAS Tools is compaible with both, ESM/import and CommonJS/require syntax.\nPlace your OpenAPI document under /api/oas-file.yaml, and create index.js and controllers/EntityController.js.Your file structure should look like this:\nserver\n├── api\n|   └── oas-file.yaml\n├── controllers\n|   └── EntityController.js\n├── node_modules\n|   └── @oas-tools\n|       └── core\n├── index.js\n├── package.json\n└── package-lock.json\nOpen controllers/EntityController.js and export a function with the same name as the operationId specified in the OpenAPI document:\n//EntityController.js\n\nmodule.exports.getEntity = function get(req, res) {\nres.send({entity: \"This is an entity object\"});\n};\nFinally, create the server entrypoint in the index.js file:\nconst http = require('http');\nconst express = require(\"express\");\nconst oasTools = require(\"@oas-tools/core\");\nconst app = express();\n\napp.use(express.json());\nconst serverPort = 8080;\n\noasTools.initialize(app).then(() => {\nhttp.createServer(app).listen(serverPort, () => console.log(\"Server started!\"));\n})\nOnce everything is done, run node index and open your new server docs in your browser. You may check the Project setup for more advanced options when setting up your project."}}}